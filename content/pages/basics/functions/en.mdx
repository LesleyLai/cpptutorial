---
title: "Functions"
---

**Functions**, also known as *procedurals* or *subroutines*,
exist in almost all imperitive programming languages
and are the backbone of *Procedural programming*.

Here is a C++ function that doubles a number and prints the result to the standard output:

```cpp
void double_and_print(int x) {
    std::cout << (2 * x) << '\n';
}
```

Up until now,
the only function we have defined is the `main` function.
We define most of our functions similarly,
by specifying a function name,
following by a *parameter list* enclosed in `()`,
then the return type,
and finally, the function body enclosed by `{}`.

You already have seen a few function calls in the tutorial so far,
as almost all the snippets use some standard library input/output functions such as `std::puts`.
To call a function, we pass *arguments* that match the parameters of the function.
In this case, we need to pass an `int` argument:

```cpp
auto main() -> int {
    double_and_print(10);
}
```

## Functions that return a value

Functions can return at most one single value to the caller.
In trailing return type syntax,
we declare the return type after an arrow (`->`).
You mark the return type as `void` if the function does not return a value.

<Info>

`void` in C++ and `unit` in some other programming languages share a lot of similarities and use cases,
but their semantics are not exactly the same.
`void` indicate an absence of return values;
on the other hand,
`unit` is a type that contains only one value.

</Info>

You must use the `return` keyword to return from a function.
For example, the below snippet should print `8`.

```cpp
auto double_x(int x) -> int {
    return 2 * x;
}

auto main() -> int {
    std::cout << double_x(4) << '\n';
}
```


## Function declaration and definition

So far, we have seen function definitions,
where we provide function name, type, and its body.
In C++, unlike in some other languages,
you can call a function without providing its definition beforehand.
When you compile the program, the linker finds the definition of functions in the whole program.

However, since C++ is a statically typed language,
the call sites need to know the types of functions.
Thus, C++ provides a lightweight alternative to definitions called declarations.
You cannot call a function without declaring it first.

A function declaration consists of the name and type of a function. For example:

```cpp
auto square(double x) -> double; // square takes a double and returns a double
```

With that declaration in place, we can already call the function `square` in our program:

```cpp
auto square(double x) -> double;

auto main() -> int
{
  std::cout << square(4); // print 16
}
```

We do need to define our function *somewhere* in our program;
otherwise, the linker will complain when we compile our program.

```cpp
// It is okay to define this function body after call sites
auto square(double x) -> double
{
  return x * x;
}
```

## Function arguments

Now let's talk about what happens to arguments passed-in to a function.

All arguments are **eagerly evaluated** and taken by copy.
We call this evaluation strategy **pass by value**.

For example, consider the following function that
adds `y` to `x` returns the final result.

```cpp
auto add(int x, int y) -> int {
    x += y;
    return x;
}
```

The argument `x` and `y` are taken by local copies of their values,
and what passed in is unchanged.

If you try to call this function in the following program:

```cpp
auto main() -> int {
    int x = 6;
    int y = 10;
    int z = add(x, y);
    std::cout << "x is " << x << ",\n"
              << "y is " << y << ",\n"
              << "z is " << z;
}
```

You will notice that the value of `x` remains at `6`.

## Overloading
TODO

## Default parameters
TODO