---
title: "Functions"
---

**Functions**, also known as *procedurals* or *subroutines*,
exist in almost all imperitive programming languages
and are the backbone of *Procedural programming*.

Here is a C++ function that doubles a number and prints the result to the standard output:

```cpp
auto double_and_print(int x) -> void {
    std::cout << (2 * x) << '\n';
}
```

Up until now,
the only function we have defined is the `main` function.
We define most of our functions similarly,
by specifying a function name,
following by a *parameter list* enclosed in `()`,
then the return type,
and finally, the function body enclosed by `{}`.

You already have seen a few function calls in the tutorial so far,
as almost all the snippets use some standard library input/output functions such as `std::puts`.
To call a function, we pass *arguments* that match the parameter list of the function.
In this case, we need to pass an `int` argument:

```cpp
auto main() -> int {
    double_and_print(10);
}
```

## Functions that return a value

Functions can return at most one single value to the caller.
In trailing return type syntax,
we declare the return type after an arrow (`->`).
You mark the return type as `void` if the function does not return a value.

<Info>

`void` in C++ and `unit` in some other programming languages share a lot of similarities and use cases,
but their semantics are not exactly the same.
`void` indicate an absence of return values;
on the other hand,
`unit` is a type that contains only one value.

</Info>

You must use the `return` keyword to return from a function.
For example, the below snippet should print `8`.

```cpp
auto double_x(int x) -> int {
    return 2 * x;
}

auto main() -> int {
    std::cout << double_x(4) << '\n';
}
```

## Function arguments

Now let's talk about what happens to arguments passed-in to a function.

All arguments are **eagerly evaluated** and taken by copy.
We call this evaluation strategy **pass by value**.

For example, consider the following function that
adds `y` to `x` returns the final result.

```cpp
auto add(int x, int y) -> int {
    x += y;
    return x;
}
```

The argument `x` and `y` are taken by local copies of their values,
and what passed in is unchanged.

If you try to call this function in the following program:

```cpp
auto main() -> int {
    int x = 6;
    int y = 10;
    int z = add(x, y);
    std::cout << "x is " << x << ",\n"
              << "y is " << y << ",\n"
              << "z is " << z;
}
```

You will notice that the value of `x` remains at `6`.